# CS50W 2021 Capstone Project - ASTATOR

## CS50's Web Programming with Python and JavaScript Final (Capstone) Project by Radan Jovic (github: radanjovic)

#### Video Demo: https://youtu.be/wnu6Z26_0xY

#### Project Requirements:
" In this project, you are asked to build a web application of your own. The nature of the application is up to you, subject to a few requirements:

Your web application must be sufficiently distinct from the other projects in this course (and, in addition, may not be based on the old CS50W Pizza project), and more complex than those.
A project that appears to be a social network is a priori deemed by the staff to be indistinct from Project 4, and should not be submitted; it will be rejected.
A project that appears to be an e-commerce site is strongly suspected to be indistinct from Project 2, and your README.md file should be very clear as to why itâ€™s not. Failing that, it should not be submitted; it will be rejected.
Your web application must utilize Django (including at least one model) on the back-end and JavaScript on the front-end.
Your web application must be mobile-responsive. "

#### Quick Project Overview:

Astator is a small web app built with *Python*. It uses *Django* as its framework on the backend for view, models and template manipulation, and *JavaScript* with a little bit of *jQuery* on the frontend. For styling purposes *Bootstrap* is also occasionally used. Finaly, for some of the icons, *Bootstrap*'s icon library and *FontAwesome*'s library are used. In terms of requirements, aside from django and other used python common libraries that come with python, installation of Pillow (fork for PIL) and python's docx libraries is required. Pillow is required for ImageFields in django models (and manipulation of user's profile pics and covers for the scripts), while docx library, which for python is named python-docx, is used to extract the text from uploaded docx files. Both are listed in requirements.txt. The app was built to be mobile-friendly, with views often changing based upon the media width, and using Bootstrap only helped achieve this goal. This app is built to be self-sustained, in a way, meaning that there is no need for input from admins: users can register, log in, add scripts and overall interact with site with almost no restrictions (provided, of course, that they do it in a way that they're intended to - meaning that they adhere to requirements of models and forms and their validations...).

In terms of the app itself, best way to describe it is this: "Astator is a small, members-only, web app built around the needs of fiction authors and aspiring authors. It enables them to share their work with other people and get first-hand impressions, suggestions, and comments before getting their work published. On Astator, authors can share their concepts (initial ideas with the overall plot and story characters), short stories, and drafts of their fiction novels, screenplays, etc. Readers can read everything on the Astator for free." Astator is latin and can mean aide, assistant or helper of a kind - which is why it's used here - this app is supposed to be of help to authors...

This means that the main role of Astator is helping authors and writers get impressions for their work, before it is published, but also to help them get general idea of the quality of their work and audience for their work which would, eventually and hopefully, lead to building a followers base - readers that would purchase published work from authors... Main inspiration behind this app is the struggle through which young (mostly first-time) authors go through after they finish writing their 'scripts' - getting honest and objective opinions, comments and suggestions for their work (getting friends and family to do it is usually not all that helpful), but also getting first readers - those that would purchase that work without knowing the author and, usually, before anyone has even rated it (on Amazon, for example, etc..).

Overview of the code and what everything is supposed to do is bellow, even though that can be seen from comments on the code as well. Here, one more note though: In comments on the code I have used an approach that stayed with me ever since law school - whenever you must address yourself in something you're writing - use we instead of I. That's how my professors taught me, and I've been using it since then - but it can be confusing (that's why I'll try and drop it for this readme file), so don't let it confuse You: I have written the code alone (and where I borrowed something from others, due credits are mentioned). 

#### Distinctiveness and Complexity

Per the requirements for this project, student is supposed to give overview on distinctiveness and complexity of their project (how it differs from other projects, especially from social media network projects), and here is mine:

This project draws upon the previos projects in this course, and borrows a little bit from each, which, in my opinion, is normal for a 'final' project. But it also separates itself from those, in multiple ways, which are displayed in the paragraph bellow this one... In terms of similarities to social network, this project shares some concepts with some of the social networks out there - but the same can be said for almost every web app out there (for example, Spotify, as we all know, is an app made for listening to the music, but even this app has concepts like following authors and adding songs to liked songs, etc..). Similarly, Astator gives users an option to add some authors to their favorite authors, but only to make it easier for them to find those authors later on, if they wish to check upon their work (to avoid being too similar to network, I have not implemented a similar following page, but user can visit favorites list on their profile and see the authors they added there). Astator also has rating system and comments and suggestions, but if one reads the above said about the purpose of the app, it would be hard to help authors without giving the ability to other users to rate the author's work and to comment on that work, or to submit some suggestions in regards to the changes they feel author should make.

Finally, in terms of complexity, this project is more complex than the others in this course (even more so if we take out of the equation parts of code that the staff wrote for us), and this (along with also the distinctiveness) can be displayed in the following: there is a total of 9 different models, each of which is important for a specific part of the app to work; the app mostly uses django's views to display desired info to users, but an API is also created for dynamically creating (and deleting) notes (but also for deleting scripts in read later and reading now), that utilizes JS and fetch. Also, My Profile page is an one-page app with 5 different views that change a part of the page on user interaction; Astator works with image and docx files (upload, storing and serving), a concept not present in other projects from this course; user authentication system is extensive: users are required to submit more data to register and their password must satisfy the django default requirements. Aside from this, users can change their profile informations after registeration, by visiting a link to edit profile. They can also change their passwords. Finally, users that forget their passwords can ask to reset their password, after which they'll get email (on the email address they type in, provided that that address is associated with a user registered on Astator(email is a required field)) with link to reset their password. I've built this auth system to be ready-to-use if I ever again need it, which is why I've put some more effort and time into it (here, also a side note: Password reset system works, code works, since I've successfully changed passwords with it multiple times during testing, but sometimes gmail (for the purposes of this project I've created an email address with them) doesn't want to send mails, and django throws SMTP Authentication error. What I've found the best to do in such times is wait a little while and try again. UPDATE: Ever since updating gmail to allow access to less secure apps AND allowing access to Display Unlock Capcha - it works every time..); Astator separates users in two groups - authors and non-authors (or just users). All the authors can be found on WriterHub page, and user can search all the authors, and the way it's implemented is with async ajax search - search as you type; Astator has an extensive rating system - it allows users to rate 3 different parts of author-submitted scripts - the storyline, characters and writing itself. Each of those can get 1-5 score, and an average is calculated with python and displayed dynamically with JS as stars. Stars are followed by chart which show percentage (as a bar) of total votes and total number of votes for each of the ratings (total number of 5s, 4s, etc.). This is supposed to give authors better insight into what they're doing right and what wrong - or better said - to isolate the field on which authors should focus more, before they try and publish their work; The main part of the app is the reading script part. Although django could store pdf files with a link which would then open that file in the user's browser's default view, I've decided to make it a bit more challenging and create my own view - or better said template for displaying the contents of user-uploaded scripts. For this purpose I used docx library to extract the content, and then passed it on to my view. The docx library seems to protect against '< script >' attacks too, since it ignored my tries to pass on JS through it, making my work easier too. Otherwise I'd have to do it manually, most likely using regex. Once in read view, which is mobile friendly (width and margins are changing depending on media width), user can chose their own font, background color and the color of the letters, and the size of the letters, adjusting their reading experince to their own preferences; Finally, once in read view, users can, if they find some part of the script they're reading interesting enough, select that part of the text upon which a button to Save Note will appear, giving them ability to save that text for later, without the need of copying and pasting. Clicking on that button saves the note in the Note model (async with js), along with the title of the script and the author, and user can see all their notes (and delete them) on their profile page...

#### Quick Code Overview
Finally, we'll take a quick look at the code and what each part of it is supposed to do.

###### settings.py (capstone)
In settings.py file in main part of the project - capstone directory, we had to accomodate for media uploads, so we added media root and media url. Also, to enable sending reset password mails we had to create smtp config with gmail. Lastly, we changed default login url to just login - instead of default accounts/login, since that's where our login view is...

###### models.py
Models.py file contains models for astator app. It has 9 models in total. First model is extended *User model*: in this model we extend the default django user model to make email, first and last name fields required. Also, we add some more fields: photo (users can upload their profile pic, but if not, a default one is added for them.. they can change this photo later on), bio (optional - authors would want to fill this, but regular users don't really need this..), and then five URL fields for links to social media profiles (also mainly for authors, so they can build their reader base better). Finally, User model has also author field, which is for separating authors from users. By default it's False (it's a BoolField), but when user submits a script, this changes to True automatically, making them visible in writerHub..
Second model is *Script model* for scripts. By script we mean all the docx files that users can upload, that we for convenience call scripts here (after manuscripts - which today can be understood as something written by the author, not necessarily by hand). Scripts link to users that posted them, have title, summary, type and category. Users must submit the file itself (the script), but uploading a cover is optional (default one is provided). Types are: concepts, short stories and drafts. Concepts are for inital ideas that authors might want to check before starting writing, short stories are for everything short in nature (blogs too, for example) and drafts are for everything long in nature - drafts of novels, screenplays and so on.. Aside from type, author specifies also the category to which script belongs (thriller, romance, ...).
Third model is for ratings. It stores all three types of ratings and links them to user that posted rating and script for which the ratings are. Fourth and fifth models are for comments and suggestions. They store comments and suggestions and link them to user and script. Difference between suggestion and comment is that suggestions are supposed to help authors more - it should containt a specific suggestion as to what the author should change and how to change it, while comments are actuall comments on the script, and can be complimentary or criticizing, etc. Sixth model is for storing scripts that a certain user has started reading. Seventh for scripts that user added to their read later list. Eighth for adding user's favorite authors to a favorite's list. Finally, ninth model is for storing user's notes.

###### urls.py
Urls.py from astator is included in ursl.py main capstone file. It contains all the urls, which are broken into groups depending on which part of the app they serve to.

###### forms.py
Forms.py file contains all the forms. In total, there is 8 classes, but most of them are for adjusting the django default forms to add classes and ids for styling later on. Forms are: Register (for registering new users, inherits from UserCreationForm), CreateScript (for creating (adding) new scripts), Comment and Suggestion (for adding those), EditProfile (for editing some parts of the user profile - email, names, photo and social media urs, inherits from UserChangeForm), ChangePassword (for changing passwords when the old password is known to user, inherits from PasswordChangeForm), and Reset- and SetNew -Password (for reseting and setting new pw when user don't know the old one). In addition, form for ratings is a custom one built in templates and validated in views.py.

###### util.py
Util.py contains helper functions, including the getText function which extracts the text from uploaded script to be later on passed to view and template, average_rating to calculate avg rating for one of the ratings on the fly, percent to calculate what percentage a certain number of votes are from the whole count of votes (to pass as bar width for our chart), and check_rating to ensure that ratings are between 1 and 5, for validation of our custom rating form.

###### admin.py
Admin.py just contains registration of all of the models for accessibility in admin panel.

###### views.py
Finally, in views.py are all the views. Quick overview of those would be: After importing all the needed libraries and function (including forms, models and utils), all categories and types are listed in dicts, as global vars for future use. *Index* view returns default index page with links to other parts of the app. *Users* view take username of user as additional query and displays page for that user, along with all their most important profile informations, their scripts (if any) and buttons for adding or removing from favorite authors. *Writerhub* view displays all the users that are marked as authors and contains search bar for searching them - search is asyng with ajax, meaning that the results are updated as the user types (actually as the user pauses between typing). *Explore* view is for all the scripts and exploring them. Users can't search here - but that's intentional - Astator is meant for non-published work, so users won't know upfront the name of the script they want to read (as opposed to authors - whose names users might know and would want to search for). Instead they can browse by script type and by script categories, depending on what they're interested in. Explore also displays a number showcasing how many scripts for each type and category there is. Users see newest scripts first and can click from there to read the script, or to open up script view - to see more info about the scripts. *Script* view is the main view - it shows each separate script, it's cover and main info, info about the author, displays charts of submitted ratings and form for rating (if user has not yet rated the script and if he is not the owner of the script), displays all the comments and suggestions with a form to add additional comms and suggs (if user is not owner), and displays buttons to read the script and add it to read later. This view is a little messy since it's the place where mentioned calculations are done and passed to the view.. *Read* view is for reading the scripts and also where we add the script to reading, once it has been clicked on and if the user is not the owner (after checking if the script is alredy in reading, to avoid duplicates). *Finish reading* view removes the script from users reading now list after user is done with the reading of it. *Read later* view removes from read later if the user did that from their myprofile page, via JS. *Delete view* deletes selected script. Only owners can delete their scripts. After the script is deleted, view checks if the user has any other scripts, and if not, it removes him from authors list (it changes his author field to False, again). *Add* and *delete* note views add or remove note via JS to Note model. *Myprofile* view shows user their profile. It contains all the info about the user, buttons to add new script and to edit profile. Then, second part of the page is one-page app for changing between seeing users scripts (if any), scripts the user is reading now (if any), scripts in read later list (if any), favorite authors (if any) and users notes (if any). *Edit profile* view is for editing profile informations, while *change password* view is for changing the pw when old pw is known. *Reset password* is not a separate view, but instead default django auth_views are used, although modified a little bit. *Create* view is for creating (adding) new scripts. Here, after successfully adding new script, author field in the User model is also adjusted to set it to True, since the user added a script. *Terms* is view for displaying terms and conditions of usage (DEMO), while *blog* and *blog posts* are views for displaying blog. Blog is also just a DEMO - for showcase what could be, since having a blog could make a difference for authors, but also the app itself - successful blog can bring new users in, can be a means for advertising the app, but also can be a source of additional income, especially if the app is free, by serving ads. Blog pages do not require being logged in (unlike all the other views), and for show, 3 pages are displayed as a demo...For the future, one might imagine a full fledged separate blog app, in which superusers (admins) would have a button to create new blog, and just enter markdown content (for example), which would then be stored in a separate db, cashed and served to users, similarly to what was done in wiki project, or something similar. Finally, *login* view, *logout* view and *register* view are for loggin users in/out and for registering new users.

###### static
Static directory holds our static files: favicon - icon displayed on browser tab and other places in app, styles.css holding our custom made css, jquery.js for jquery, and script.js for our own JS functions. In this file, first part is for async writer search, a code borrowed from SHxKM from GitHub. Second part is for one-page myprofile app - changing the view on click. Third part is for read view and adjusting the read view to preferences of users (changing fonts, bcgr and text color, and text size upon clicks on the buttons), Fourth part is for adding Save Note button and adding functionality to that button. Fifth part is for deleting selected note, sixth for adjusting rating stars based on the avg_rating. Seventh part is for removing script from read later, and eighth is for removing scripts from reading now when user id finished reading.

###### templates
Templates directory holds the templates in two directories, one is just for demo blog pages, and the other is for actually holding the templates for astator. Novelty are 4 templates for reseting password which are not addressed in view, because they are passed directly to urls.py (auth_views).

###### media
Media directory holds all the media files uploaded by the users, and the default ones that are provided in case users don't select their own profile pic's and cover pic's. 